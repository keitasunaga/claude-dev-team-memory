# 使用ガイド

このガイドでは、Claude Codeの開発セッションでMCPメモリサーバーを効果的に使用する方法を説明します。

## 概要

MCPメモリサーバーは2種類のメモリを提供します：

1. **グローバルメモリ**: すべてのプロジェクトで永続化される個人設定
2. **プロジェクトメモリ**: 各プロジェクトに固有のコンテキスト

## 基本概念

### グローバル設定

すべてのプロジェクトでClaudeが記憶する個人的な開発設定：

- 言語設定（例：「日本語で応答」）
- パッケージマネージャーの選択（例：「pnpmを使用」）
- コードスタイルの設定（例：「インデントは2スペース」）
- テスト要件（例：「80%のカバレッジを確保」）
- コミットメッセージ形式（例：「Conventional Commitsを使用」）

### プロジェクトコンテキスト

各プロジェクトは独自のメモリを維持：

- 現在のIssue詳細と要件
- 完了状態を含むタスクリスト
- 開発チェックポイント
- セッション状態（現在のブランチ、変更されたファイル）
- 設計決定と技術的なメモ

## メモリ機能の使用

### グローバル設定の保存

自然な言語でClaudeに設定について伝えるだけです：

```
「npmの代わりにpnpmを使うことを覚えて」
「TypeScriptは常にstrictモードを有効にして」
「日本語で返答してください」
「Conventional Commits仕様に従います」
```

Claudeは自動的に`save_global_preference`ツールを使用してこれらの設定を保存します。

### 設定の取得

Claudeに設定について尋ねる：

```
「私の開発設定は何？」
「パッケージマネージャーの設定を覚えてる？」
「私が使うコーディングスタイルは？」
```

### プロジェクトコンテキストの操作

#### 新しいIssueの開始

新しいIssueの作業を始めるとき：

```
「Issue #42: ユーザー認証の追加の作業を開始します」
「要件は：JWTベースの認証、リフレッシュトークン、ロールベースのアクセス制御」
「設計決定：Passport.jsを使用、ユーザーストレージにPostgreSQL」
```

Claudeはこのコンテキストを保存し、セッション間で記憶します。

#### タスクの管理

タスクを作成して追跡：

```
「以下のタスクを追加：
1. Passport.jsのセットアップ
2. ユーザーモデルの作成
3. JWT戦略の実装
4. 認証ミドルウェアの追加
5. ログイン/ログアウトエンドポイントの作成」

「タスク1を完了にマーク」
「残りのタスクは何？」
```

#### チェックポイントの作成

重要な時点で進捗を保存：

```
「リファクタリングを始める前にチェックポイントを作成」
「チェックポイントを保存：認証実装完了」
「'pre-deploy-v1.0'という名前でチェックポイントを作成」
```

#### チェックポイントからの復元

以前の状態に戻る：

```
「利用可能なチェックポイントを一覧表示」
「'pre-refactoring'という名前のチェックポイントから復元」
「昨日のチェックポイントに戻る」
```

## 実践的なワークフロー

### 日々の開発フロー

1. **朝の開始**
   ```
   あなた: 「このプロジェクトで何を作業していた？」
   Claude: [プロジェクトコンテキストを取得し、現在のIssue、タスク、進捗を表示]
   ```

2. **開発中**
   ```
   あなた: 「ユーザーモデルの実装を完了しました」
   Claude: [タスクステータスを更新し、自動保存をトリガー]
   ```

3. **大きな変更の前**
   ```
   あなた: 「認証システムをリファクタリングする前にチェックポイントを作成」
   Claude: [現在の状態でチェックポイントを作成]
   ```

4. **一日の終わり**
   ```
   あなた: 「現在のセッション状態を保存」
   Claude: [変更されたファイルと現在のブランチを含むすべてのコンテキストを保存]
   ```

### コンテキスト喪失の処理

Claudeがコンテキストを失った場合（例：タイムアウト後）：

```
あなた: 「前のセッションを復元」
Claude: [最後のセッション状態を自動的に取得し、中断した場所から続行]
```

### マルチプロジェクト開発

プロジェクト間の切り替え：

```
あなた: 「フロントエンドプロジェクトに切り替えます」
Claude: [フロントエンドプロジェクトの特定のコンテキストをロード]

あなた: 「APIプロジェクトのステータスは？」
Claude: [切り替えることなくAPIプロジェクトのコンテキストを取得して表示]
```

## 高度な機能

### 自動保存トリガー

サーバーは以下のタイミングで自動的にチェックポイントを作成：
- タスクが完了としてマークされたとき
- テストが正常に通過したとき
- 明示的にチェックポイントを要求したとき
- 定期的な間隔で（設定可能）

### セッション状態の追跡

サーバーが追跡する内容：
- 現在のGitブランチ
- 変更されたファイルのリスト
- アクティブなタスク
- 最後のチェックポイントのタイムスタンプ

### チェックポイント管理

```
「現在の状態を最後のチェックポイントと比較」
「古いチェックポイントを削除して最新の5つだけを保持」
「'pre-refactoring'チェックポイント以降の変更を表示」
```

## ベストプラクティス

### 1. チェックポイントには説明的な名前を付ける

代わりに：
```
「チェックポイントを作成」
```

使用：
```
「チェックポイントを作成：GoogleプロバイダーでのOAuth実装完了」
```

### 2. 定期的なコンテキスト更新

Claudeに進捗を知らせ続ける：
```
「データベースマイグレーションを完了しました」
「認証ミドルウェアにバグを発見、修正に取り組んでいます」
「セッションストレージにRedisを使用するアプローチに切り替えます」
```

### 3. 明確なタスク説明を使用

代わりに：
```
「タスクを追加：バグ修正」
```

使用：
```
「タスクを追加：JWTリフレッシュロジックの認証タイムアウトバグを修正」
```

### 4. グローバル設定を活用

一度設定すればClaudeが記憶：
```
「常に以下を行ってください：
- promiseの代わりにasync/awaitを使用
- すべての関数にJSDocコメントを追加
- RESTfulな命名規則に従う」
```

## ヒントとコツ

### クイックステータスチェック
```
「現在のステータスは？」 - アクティブなIssue、現在のタスク、セッション情報を表示
```

### 一括タスク管理
```
「タスク2、3、5を完了にマーク」
「すべての保留中のタスクを進行中に移動」
```

### コンテキスト検索
```
「認証システムの設計決定は何だった？」
「テストに関連するすべてのタスクを表示」
```

### 時間ベースのクエリ
```
「昨日は何を作業していた？」
「今週のチェックポイントを表示」
```

## メモリの構成

サーバーは以下のようにメモリを整理：

```
グローバルメモリ:
├── language: "Japanese"
├── package_manager: "pnpm"
├── testing: "vitest with 80% coverage"
└── code_style: "prettier with 2 spaces"

プロジェクトメモリ（プロジェクトごと）:
├── Issueコンテキスト:
│   ├── number: "#42"
│   ├── title: "認証の追加"
│   ├── requirements: [...]
│   └── design_decisions: [...]
├── タスク:
│   ├── completed: []
│   ├── in_progress: {}
│   └── pending: []
└── セッション:
    ├── branch: "feature/auth"
    ├── modified_files: []
    └── last_checkpoint: "2024-01-20T10:30:00Z"
```

## 使用上のトラブルシューティング

### メモリが永続化されない

1. サーバーの健全性を確認: 「メモリサーバーのステータスを確認」
2. 保存を検証: 「最後の設定を保存した？」
3. ログでエラーを探す

### 間違ったコンテキストがロードされる

1. プロジェクトを確認: 「どのプロジェクトにいる？」
2. パスを確認: 「プロジェクトパスは？」
3. 手動で指定: 「/path/to/projectのコンテキストをロード」

### チェックポイントの問題

1. チェックポイントを一覧表示: 「すべてのチェックポイントを表示」
2. 特定のチェックポイントを検証: 「チェックポイント'X'は有効？」
3. フォールバックを使用: 「最後から2番目のチェックポイントから復元」

## 開発ツールとの統合

### Git統合
```
「現在のブランチをセッション状態に保存」
「最後のセッションではどのブランチにいた？」
```

### Issue Tracker統合
```
「GitHub Issue #42からIssueコンテキストを更新」
「JiraチケットABC-123からこれらの要件を保存」
```

### IDE状態
```
「これらのファイルを開いていたことを覚えて：[ファイルリスト]」
「どのファイルで作業していた？」
```

## 次のステップ

- カスタマイズについては[設定オプション](CONFIG.ja.md)を確認
- [セキュリティのベストプラクティス](SECURITY.ja.md)を読む
- カスタムツールについては[API統合](API.ja.md)を学ぶ
- 一般的な問題については[トラブルシューティングガイド](TROUBLESHOOTING.ja.md)を確認